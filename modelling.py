def train_predictor(train_data):
    """
    trains the dense network part of the model
    inputs: feature maps after PCA
    :return: saves the model parameters
    """
    print("This has not be implemented yet.")


def evaluate():
    """
    calculate evaluation score
    :return: prints evaluation score overview, maybe returns measures
    """

    # def vectorized_correlation(x, y):
    #     dim = 0
    #
    #     centered_x = x - x.mean(axis=dim, keepdims=True)
    #     centered_y = y - y.mean(axis=dim, keepdims=True)
    #
    #     covariance = (centered_x * centered_y).sum(axis=dim, keepdims=True)
    #
    #     covariance = covariance / (x.shape[dim])
    #
    #     x_std = x.std(axis=dim, keepdims=True) + 1e-8
    #     y_std = y.std(axis=dim, keepdims=True) + 1e-8
    #
    #     corr = covariance / (x_std * y_std)
    #
    #     return corr.ravel()

    print("This has not be implemented yet.")